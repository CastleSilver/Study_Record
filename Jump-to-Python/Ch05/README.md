## 클래스
### 클래스란
```
def 함수명(매개변수):
    수행할 문장
    ...
```
+ 클래스는 붕어빵을 찍어내는 틀이고
+ 객체는 붕어빵이다.
+ 각 객체는 독립적이다.
```py
def setdata(self, first, second):   # ① 메서드의 매개변수
    self.first = first              # ② 메서드의 수행문
    self.second = second            # ② 메서드의 수행문
```
### 메서드의 매개변수
![](https://velog.velcdn.com/images/aysel0230/post/77950091-7986-4166-b62c-81ac766f2a97/image.png)
+ 메서드의 첫 번째 매개변수 self에는 setdata메서드를 호출한 객체 a가 자동으로 전달된다.
+ 클래스를 통해 호출할 수도 있지만 이때는 첫번째 매개변수를 명시해야 한다.
```py
>>> a = FourCal()
>>> FourCal.setdata(a, 4, 2)
```
### 생성자(Constructor)
+ 파이썬 메서드 이름으로 `__init__`를 사용하면 이 메서드는 생성자가 된다.
+ 생성자도 첫 번째 매개변수는 호출한 객체가 들어간다.
+ 생성자의 매개변수 수에 맞게 객체를 생성할 때 인자의 개수를 맞춰서 넣어줘야 한다.
### 상속
```
class 클래스 이름(상속할 클래스 이름)
```
+ 클래스를 상속하기 위해서는 클래스 이름 뒤 괄호 안에 상속할 클래스 이름을 넣어주면 된다.
+ 상속은 기존 클래스를 변경하지 않고 기능을 추가하거나 기존 기능을 변경하려고 할 때 사용한다.
### 오버라이딩(Overriding)
+ 부모 클래스(상속한 클래스)에 있는 메서드를 동일한 이름으로 다시 만드는 것을 의미한다.
+ 메서드를 오버라이딩하면 부모클래스의 메서드 대신 오버라이딩한 메서드가 호출된다.

### 클래스 변수
+ `클래스이름.클래스 변수`로 사용할 수 있다.

<br/>

## 모듈
> 모듈이란 함수나 변수 또는 클래스를 모아 놓은 파일이다. 모듈은 다른 파이썬 프로그램에서 불러와 사용할 수 있게끔 만든 파이썬 파일이라고도 할 수 있다. 다른 사람들이 이미 만들어 놓은 모듈을 사용할 수도 있고 우리가 직접 만들어서 사용할 수도 있다. 파이썬 확장자 .py로 만든 파이썬 파일은 모두 모듈이다.

### 모듈 사용하기
+ `import 모듈이름` 을 하고 `모듈이름.모듈함수`를 하면 함수를 사용할 수 있다. 
+ `from 모듈이름 import 모듈함수`를 하면 모듈함수만 불러 사용할 수 있다.
+ 모듈함수 자리에 `*`를 하면 모든 함수를 사용할 수 있다.
+ 클래스나 변수도 포함하여 사용할 수 있다.

### `if __name__ == "__main__":`
+ `if __name__ == "__main__"`을 사용하면 직접 이 파일을 실행했을 때는 `__name__ == "__main__"`이 참이 되어 if문 다음 문장이 수행된다. 반대로 대화형 인터프리터나 다른 파일에서 이 모듈을 불러서 사용할 때는 `__name__ == "__main__"`이 거짓이 되어 if문 다음 문장이 수행되지 않는다.
+  `__name__` 변수는 파이썬이 내부적으로 사용하는 특별한 변수 이름이다. 직접 파일을 실행할 경우 `__name__` 변수에는 `__main__` 값이 저장된다. 하지만 파이썬 셸이나 다른 파이썬 모듈에서 import 할 경우에는 `__name__` 변수에는 모듈 이름 값이 저장된다.

### 다른 파일에서 모듈 불러오기
+ 파이썬 모듈이 sys 디렉터리에 들어 있다면 모듈이 저장된 디렉터리로 이동할 필요 없이 바로 불러서 사용할 수 있다.
+ 만약 불러오려는 모듈이 그 디렉터리에 포함되어 있지 않다면 `sys.path.append(모듈저장위치)`로 추가해 사용할 수 있다.

### PYTHONPATH 환경 변수 사용하기
```py
C:\doit>set PYTHONPATH=C:\doit\mymod
C:\doit>python
>>> import mod2
>>> print(mod2.add(3,4))
7
```
+ set 명령어를 사용해 PYTHONPATH 환경 변수에 mod2.py 파일이 있는 C:\doit\mymod 디렉터리를 설정한다. 그러면 디렉터리 이동이나 별도의 모듈 추가 작업 없이 mod2 모듈을 불러와서 사용할 수 있다.

<br/>

## 패키지
> 패키지(Packages)는 도트(.)를 사용하여 파이썬 모듈을 계층적(디렉터리 구조)으로 관리할 수 있게 해준다. 

### 패키지 안의 함수 사용하기
+ 필요한 모듈을 import해서 사용한다.
+ import a.b.c처럼 import할 때 가장 마지막 항목은 반드시 모듈 또는 패키지여야만 한다.

### `__init__.py` 의 용도
+ `__init__.py` 파일은 해당 디렉터리가 패키지의 일부임을 알려주는 역할을 한다. 
+ 만약 패키지에 포함된 디렉터리에 `__init__.py` 파일이 없다면 패키지로 인식되지 않는다.
+ python3.3 버전부터는 `__init__.py` 파일이 없어도 패키지로 인식한다. 하지만 하위 버전 호환을 위해 `__init__.py` 파일을 생성하는 것이 안전한 방법이다.
+ 특정 디렉터리의 모듈을 *를 사용하여 import할 때에는 해당 디렉터리의 `__init__.py` 파일에 `__all__` 변수를 설정하고 import할 수 있는 모듈을 정의해 주어야 한다.
```
# 예시
# C:/doit/game/sound/__init__.py
__all__ = ['echo']
```

### relative 패키지

```py
# 다음과 같이 사용가능 하지만
>>> from game.graphic.render import render_test
>>> render_test()
render
echo

# relative 패키지를 이용해서 사용가능하다.
from ..sound.echo import echo_test

def render_test():
    print("render")
    echo_test()
```
+ .. – 부모 디렉터리
+ . – 현재 디렉터리

<br/>

## 예외처리
### 오류 예외 처리 기법
#### try, except
```
try:
    ...
except [발생 오류[as 오류 메시지 변수]]:
    ...
```
+ try 블록 수행 중 오류가 발생하면 except 블록이 수행된다. 하지만 try 블록에서 오류가 발생하지 않는다면 except 블록은 수행되지 않는다.
+ 발생 오류는 생략할 수 있다. 발생오류가 생략되면 오류 메시지 변수는 사용할 수 없다.
+ 오류 메시지 변수는 생략될 수 있다.

#### try..finally
+ finally절은 try문 수행 도중 예외 발생 여부에 상관없이 항상 수행된다. 

#### 여러개의 오류처리하기
```
try:
    ...
except 발생 오류1:
   ... 
except 발생 오류2:
   ...
```
#### try문에 else절 사용하기
```
try:
    ...
except [발생 오류[as 오류 메시지 변수]]:
    ...
else:  # 오류가 없을 경우에만 수행된다.
    ...
```
### 오류 회피하기

```py
try:
    f = open("나없는파일", 'r')
except FileNotFoundError:
    pass
```
+ try문 안에서 FileNotFoundError가 발생할 경우에 pass를 사용하여 오류를 그냥 회피하도록 작성한 예제이다.
### 오류 일부러 발생시키기
+ raise 명령어를 사용해 오류를 강제로 발생시킬 수 있다.
```py
class Bird:
    def fly(self):
        raise NotImplementedError
```
+ Bird 클래스를 상속받으면 fly 메서드를 꼭 구현해야 한다.

### 예외 만들기
+ 예외는 다음과 같이 파이썬 내장 클래스인 Exception 클래스를 상속하여 만들 수 있다.
```py
class MyError(Exception):
    pass
```
<br/>

## 내장 함수
### all
+ all(x)는 반복 가능한(iterable) 자료형 x를 입력 인수로 받으며 이 x의 요소가 모두 참이면 True, 거짓이 하나라도 있으면 False를 돌려준다.
+ 만약 all의 입력 인수가 빈 값인 경우에는 True를 리턴한다.
```py
>>> all([1, 2, 3, 0])
False

>>> all([])
True
```

### any
+ any(x)는 반복 가능한(iterable) 자료형 x를 입력 인수로 받으며 이 x의 요소 중 하나라도 참이 있으면 True를 돌려주고, x가 모두 거짓일 때에만 False를 돌려준다. all(x)의 반대이다.

### chr
+ chr(i)는 유니코드(Unicode) 값을 입력받아 그 코드에 해당하는 문자를 출력하는 함수이다.

### dir
+ dir은 객체가 자체적으로 가지고 있는 변수나 함수를 보여 준다. 
```py
>>> dir([1, 2, 3])
['append', 'count', 'extend', 'index', 'insert', 'pop',...]
>>> dir({'1':'a'})
['clear', 'copy', 'get', 'has_key', 'items', 'keys',...]
```
### divmod
+ divmod(a, b)는 2개의 숫자를 입력으로 받는다. 그리고 a를 b로 나눈 몫과 나머지를 튜플 형태로 돌려주는 함수이다.

### enumerate
+ 이 함수는 순서가 있는 자료형(리스트, 튜플, 문자열)을 입력으로 받아 인덱스 값을 포함하는 enumerate 객체를 돌려준다.

### eval
+ 실행 가능한 문자열을 입력으로 받아 문자열을 실행한 결괏값을 돌려주는 함수이다.
```py
>>> eval('1+2')
3
>>> eval("'hi' + 'a'")
'hia'
```
### filter
+ filter 함수는 첫 번째 인수로 함수 이름을, 두 번째 인수로 그 함수에 차례로 들어갈 반복 가능한 자료형을 받는다. 그리고 두 번째 인수인 반복 가능한 자료형 요소가 첫 번째 인수인 함수에 입력되었을 때 반환 값이 참인 것만 묶어서(걸러 내서) 돌려준다.
```py
#filter1.py
def positive(x):
    return x > 0

print(list(filter(positive, [1, -3, 2, 0, -5, 6])))
```

### isinstance
+ isinstance(object, class )는 첫 번째 인수로 인스턴스, 두 번째 인수로 클래스 이름을 받는다. 입력으로 받은 인스턴스가 그 클래스의 인스턴스인지를 판단하여 참이면 True, 거짓이면 False를 돌려준다.

### map
+ map(f, iterable)은 함수(f)와 반복 가능한(iterable) 자료형을 입력으로 받는다. map은 입력받은 자료형의 각 요소를 함수 f가 수행한 결과를 묶어서 돌려주는 함수이다.

### zip
+ zip(*iterable)은 동일한 개수로 이루어진 자료형을 묶어 주는 역할을 하는 함수이다.
```py
>>> list(zip([1, 2, 3], [4, 5, 6]))
[(1, 4), (2, 5), (3, 6)]
>>> list(zip([1, 2, 3], [4, 5, 6], [7, 8, 9]))
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
>>> list(zip("abc", "def"))
[('a', 'd'), ('b', 'e'), ('c', 'f')]
```
<br/>

## 라이브러리
### sys
+ sys 모듈은 파이썬 인터프리터가 제공하는 변수와 함수를 직접 제어할 수 있게 해주는 모듈이다.
+ sys.argv - 명령 행에서 인수 전달하기
+ sys.exit - 강제로 스크립트 종료하기
+ sys.path - 자신이 만든 모듈 불러와 사용하기

### pickle
+ pickle은 객체의 형태를 그대로 유지하면서 파일에 저장하고 불러올 수 있게 하는 모듈이다.
+ pickle.dump로 저장한 파일을 pickle.load를 사용해서 원래 파일 그대로 불러올 수 있다.

### OS
+ OS 모듈은 환경 변수나 디렉터리, 파일 등의 OS 자원을 제어할 수 있게 해주는 모듈이다.
+ os.environ - 내 시스템의 환경 변수값을 알고 싶을 때
+ os.chdir - 디렉터리 위치 변경하기
+ os.getcwd - 디렉터리 위치 돌려받기 
+ os.system - 시스템 명령어 호출하기 
+ os.popen - 실행한 시스템 명령어의 결괏값 돌려받기 

### shutil
+ 파일을 복사해 주는 파이썬 모듈이다.
```py
>>> import shutil
>>> shutil.copy("src.txt", "dst.txt")
```

### glob
+ 정 디렉터리에 있는 파일 이름 모두를 알아야 할 때 사용한다.
+ glob(pathname) - 디렉터리에 있는 파일들을 리스트로 만들기 

### tempfile
+ 파일을 임시로 만들어서 사용할 때 유용하다.
+ tempfile.mkstemp() - 중복되지 않는 임시 파일의 이름을 무작위로 만들어서 돌려준다.
+ tempfile.TemporaryFile() - 임시 저장 공간으로 사용할 파일 객체를 돌려준다. 

이 외에도 다양한 라이브러리가 있으니 필요할 때 찾아서 사용법을 익히면 좋을 것 같다.
