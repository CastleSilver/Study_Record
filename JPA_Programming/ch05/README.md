# 연관관계 매핑 기초
## 단방향 연관관계
객체는 참조를 통해 연관관계를 항상 탐색할 수 있는데 이를 **객체 그래프 탐색**이라 한다. 참조를 통한 탐색은 항상 단방향이다. 반면 테이블은 외래 키 하나로 양방향으로 조인할 수 있다. 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다. 

## 연관관계를 매핑하기 위한 애노테이션
### @JoinColumn
![](https://velog.velcdn.com/images/aysel0230/post/eff3b768-0ae9-480b-b71d-8348fffd09a8/image.png)
@JoinColumn을 생략하면 외래 키를 찾을 때 기본 전략(`필드명`+`_`+`참조하는 테이블의 컬럼명`)을 사용한다.

### @ManyToOne/@OneToMany/@OneToOne
다대일 관계에서 사용한다.
![](https://velog.velcdn.com/images/aysel0230/post/04fa2750-f946-4f57-9792-fa10891915f2/image.png)

## 연관관계 사용
### 저장
![](https://velog.velcdn.com/images/aysel0230/post/921ae477-4346-4c5d-8be1-3522fd89abc0/image.png)
위 예제와 같이 참조한 팀의 식별자를 외래 키로 사용해 적절한 등록 쿼리를 생성한다.

### 조회
연관관계가 있는 엔티티를 조회하는 방법은 2가지가 있다.
### 객체 그래프 탐색
`member.getTeam()`과 같이 객체를 통해 연관된 엔티티를 조회하는 것을 말한다.
### 객체지향 쿼리 사용(JPQL)
![](https://velog.velcdn.com/images/aysel0230/post/0a814657-142c-4921-a90f-4aa37b765069/image.png)
`:`로 시작하는 것은 파라미터를 바인딩받는 문법이다.

### 수정
엔티티의 값만 변경하면 트랜잭션을 커밋할 때 플러시가 일어나면서 변경 감지 기능이 작동한다.

### 제거
+ 연관관계 제거 : 연관관계를 `null`로 설정한다.
+ 연관된 엔티티 삭제 : 연관된 엔티티를 삭제하려면 기존에 있는 연관관계를 먼저 제거하고 `remove()`를 이용해 엔티티를 삭제하면 된다.

## 양방향 연관관계
+ mappedBy 속성 추가 : 양방향 매핑일 때 사용하는데 반대쪽 매핑의 필드 이름을 값으로 주면 된다.

## 연관관계의 주인
엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나다. 따라서 둘 사이에 차이가 발생한다. 이런 차이로 인해 JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래 키를 관리하는 데 이를 **연관관계의 주인**이라 한다.

### 양방향 매핑의 규칙
양방향 연관관계 매핑 시 두 연관관계 중 하나를 연관관계의 주인으로 정해야 한다. 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리할 수 있다. 반면 주인이 아닌 쪽은 읽기만 할 수 있다. 어떤 쪽을 주인으로 할지는 mappedBy 속성을 사용하면 된다. 주인은 mappedBy 속성을 사용하지 않는다. 연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야 한다. 

## 양방향 연관관계 저장 
주인이 아닌 방향은 값을 설정하지 않아도 데이터베이스에 외래 키 값이 정상 입력된다. 주인이 아닌 곳에 입력된 값은 외래 키에 영향을 주지 않는다.

## 양방향 연관관계의 주의점
주인이 아닌 곳에 입력된 값은 외래 키에 영향을 주지 않는 것이 맞지만 순수한 객체 상태에서도 동작하기 위해 다음 예시와 같이 주인이 아닌 곳에도 값을 입력해주도록 하자. 또한 연관관계 변경 시 기존 연관관계를 삭제하는 코드도 추가하였다.
```java
public class Member {
	private Team team;
    
    public void setTeam(Team team) {
    
    	// 기존 팀과 관계를 제거
        if(this.team != null) {
        	this.team.getMembers().remove(this);
        }
    	this.team = team;
        team.getMembers().add(this);
    }
}
```

