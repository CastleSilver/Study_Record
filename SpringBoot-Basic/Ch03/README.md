## 강의 목표
+ 객체지향 설계 원칙을 준수하여 애플리케이션 구현
+ SRP<sub>한 클래스가 하나의 책임만 가지는 것</sub> 준수하기
+ OCP, DIP 원칙을 준수하지 못했던 것을 수정
  + DIP : 클라이언트 코드가 추상 클래스에만 의존하기
  + OCP : 확장에는 열려있고 변경에는 닫혀있기

## 설계
+ DI 컨테이너
  + 구현객체를 생성하고, 연결하는 책임을 가지는 설정 클래스를 구현
  + 생성자를 통해 의존관계를 주입해준다.
  + DI 컨테이너를 구현함으로써 클래스 간 역할 구분이 명확해진다.
  + 클라이언트 코드를 변경하지 않아도 의존관계를 변경할 수 있게 되었다.
  ![image](https://user-images.githubusercontent.com/95426849/173193006-a82374f8-ae7e-4617-aee8-2727cd812bf4.png)
 
 ## IoC, DI, 스프링 컨테이너
 ### 제어의 역전(Inversion of Control)
 + 클라이언트 코드가 구현 객체를 생성하고, 연결하고, 실행했던 것을 외부 컨테이너가 생성하고 연결 기능을 분담함으로써 클라이언트 코드가 실행 역할만 맡게 되는 것
 + 즉 프로그램의 제어 흐름을 외부에서 관리하는 것을 제어의 역전이라 한다.
 ### 의존관계 주입(Dependency Injection)
 + 클라이언트 코드는 인터페이스에만 의존하고 실제 어떤 구현 객체가 사용될지는 모른다.
 + 의존 관계는 정적인 클래스 의존관계와, 실행 시점에 결정되는 동적인 객체 의존 관계를 분리해서 생각해야 한다.
 + 정적인 의존관계는 애플리케이션을 실행하지 않고 import 코드만 보고도 쉽게 판단할 수 있지만, 동적인 의존 관계는 애플리케이션 실행 시점에 인스턴스가 생성되어 연결된다.
### 스프링 컨테이너
+ `ApplicationContext`를 스프링 컨테이너라 한다.
+ `@Configuration`이 붙은 클래스를 설정 정보로 사용한다. 이 클래스 내에 `@Bean`이 붙은 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 이 객체들은 스프링 빈이라 불린다.
+ 스프링 빈은 메서드 명을 이름으로 사용한다.
+ 스프링 빈은 `applicationContext.getBean()` 메서드를 이용해 찾을 수 있다.
